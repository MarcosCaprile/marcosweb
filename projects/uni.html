<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D-Sonnensystem (N-Body, Velocity-Verlet, Mond, Sterne)</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#000; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #hud{
      position:fixed; left:12px; top:12px; z-index:10;
      background:rgba(0,0,0,.55); border:1px solid rgba(255,255,255,.12);
      padding:10px 12px; border-radius:12px; color:#fff; min-width:300px;
      backdrop-filter: blur(6px);
    }
    #hud .title{ font-weight:700; margin-bottom:6px; }
    #hud label{ display:block; font-size:12px; opacity:.9; margin-top:10px; }
    #hud select, #hud input[type="range"], #hud button{
      width:100%;
      margin-top:6px;
    }
    #hud select, #hud button{
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.15);
      color:#fff; padding:8px; border-radius:10px;
    }
    #hud button{ cursor:pointer; }
    #hud small{ display:block; margin-top:10px; opacity:.75; line-height:1.25; }
    #timeBox{
      position:fixed; right:12px; top:12px; z-index:10;
      background:rgba(0,0,0,.35); border:1px solid rgba(255,255,255,.10);
      color:rgba(255,255,255,.85); padding:8px 10px; border-radius:12px;
      backdrop-filter: blur(6px);
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size:12px;
    }
    #err{
      position:fixed; left:12px; bottom:12px; z-index:9999;
      color:#ffd7d7; background:rgba(120,0,0,.45);
      border:1px solid rgba(255,120,120,.4);
      padding:10px 12px; border-radius:12px; max-width:700px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      display:none; white-space:pre-wrap;
    }
  </style>
</head>
<body>
  <div id="hud">
    <div class="title">3D-Sonnensystem (wie dein Python-Code)</div>

    <button id="resetBtn">Kamera zurücksetzen</button>

    <label>Körper folgen</label>
    <select id="followSelect"></select>

    <label>Tage pro Schritt (dt)</label>
    <input id="daysRange" type="range" min="0.1" max="50" value="1" step="0.1" />
    <div style="display:flex;justify-content:space-between;font-size:12px;opacity:.85;margin-top:4px;">
      <span>0.1</span><span id="daysValue">1.0</span><span>50</span>
    </div>

    <label>Simulationsschritte pro Frame (Genauigkeit)</label>
    <input id="substepsRange" type="range" min="1" max="25" value="6" step="1" />
    <div style="display:flex;justify-content:space-between;font-size:12px;opacity:.85;margin-top:4px;">
      <span>1</span><span id="substepsValue">6</span><span>25</span>
    </div>

    <label style="display:flex;gap:10px;align-items:center;margin-top:10px;">
      <input id="idealOrbitsCheck" type="checkbox" checked style="width:auto;margin:0;">
      <span style="font-size:12px;opacity:.9;">Ideale Ellipsenbahnen (dashed) anzeigen</span>
    </label>

    <label style="display:flex;gap:10px;align-items:center;margin-top:8px;">
      <input id="trailsCheck" type="checkbox" checked style="width:auto;margin:0;">
      <span style="font-size:12px;opacity:.9;">Trails (Spuren) anzeigen</span>
    </label>

    <small>
      Maus: Linksklick ziehen = umsehen • Scroll = zoomen • Rechtsklick ziehen = verschieben<br>
      Zoom ist wie im Python-Code zentriert auf Follow-Körper (falls gewählt), sonst auf die Szenenmitte.
    </small>
  </div>

  <div id="timeBox">t = 0.00 Jahre (0 Tage)</div>
  <div id="err"></div>

  <!-- Non-module CDN (läuft meist auch bei file://) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.161.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    const errBox = document.getElementById("err");
    function showError(e) {
      errBox.style.display = "block";
      errBox.textContent =
        "Fehler:\n" + (e && e.stack ? e.stack : String(e)) +
        "\n\nWenn das im Schulnetz ist: CDN-Links könnten blockiert sein.";
    }
    window.addEventListener("error", (ev) => showError(ev.error || ev.message));
    window.addEventListener("unhandledrejection", (ev) => showError(ev.reason));

    // ============================================================
    // Einheiten exakt wie im Python:
    //  - Entfernung: AU
    //  - Zeit: Jahre
    //  - Masse: Sonnenmassen
    //  -> G = 4*pi^2
    // ============================================================
    const G = 4 * Math.PI * Math.PI;
    const DAY_IN_YEARS = 1.0 / 365.25;

    // Referenz-Erdradius in km (für Größen-Skalierung)
    const R_EARTH_KM = 6371.0;

    // Visual-Scaling: Planetenradien sind in AU extrem winzig -> wir skalieren Marker,
    // aber untereinander bleibt das Verhältnis erhalten (wie marker_size_from_radius).
    const VISUAL_RADIUS_SCALE = 1.0; // wir nutzen marker_size_from_radius (ähnlich), nicht AU*Scale

    // Trails
    const TRAIL_MAX_POINTS = 2400;

    // Szene
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.setClearColor(0x000000, 1);
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.0006);

    const camera = new THREE.PerspectiveCamera(55, innerWidth / innerHeight, 0.001, 5000);
    camera.position.set(0, 6, 16);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.enablePan = true;

    // Licht
    scene.add(new THREE.AmbientLight(0xffffff, 0.18));
    const sunLight = new THREE.PointLight(0xffffff, 2.2, 0, 2);
    sunLight.position.set(0, 0, 0);
    scene.add(sunLight);

    // ============================================================
    // Body Klasse (JS-Äquivalent)
    // ============================================================
    class Body {
      constructor({ name, mass, a=null, e=0.0, inc_deg=0.0, color=0xffffff, radius_km=0.0 }) {
        this.name = name;
        this.mass = mass;
        this.a = a;
        this.e = e;
        this.inc_deg = inc_deg;
        this.color = new THREE.Color(color);
        this.radius_km = radius_km;

        // Zustand
        if (a === null) {
          this.x = this.y = this.z = 0.0;
          this.vx = this.vy = this.vz = 0.0;
        } else {
          // Start im Perihel
          const r_peri = a * (1 - e);
          this.x = r_peri; this.y = 0.0; this.z = 0.0;

          // Perihel-Geschwindigkeit (Kepler um Sonne) wie im Python:
          // v_peri = sqrt(G*(1+e)/(a*(1-e))) (Sonne hat mass=1)
          const v_peri = Math.sqrt(G * (1 + e) / (a * (1 - e)));
          this.vx = 0.0; this.vy = v_peri; this.vz = 0.0;
        }

        this.ax = this.ay = this.az = 0.0;

        // Visuals
        const ms = marker_size_from_radius(this); // ähnlich wie matplotlib markersize
        // Wir mappen markersize grob in eine Kugelgröße (AU-unabhängig)
        const visualRadius = (ms / 80); // Tuning: größer = sichtbarer
        const geo = new THREE.SphereGeometry(Math.max(visualRadius, 0.01), 32, 32);

        const mat = new THREE.MeshStandardMaterial({
          color: this.color,
          roughness: 0.7,
          metalness: 0.0,
          emissive: (this.name === "Sonne") ? new THREE.Color(0xffaa33) : new THREE.Color(0x000000),
          emissiveIntensity: (this.name === "Sonne") ? 0.9 : 0.0
        });

        this.mesh = new THREE.Mesh(geo, mat);
        this.mesh.position.set(this.x, this.y, this.z);
        scene.add(this.mesh);

        // Trail
        this.trail = makeTrail(this.color);
        scene.add(this.trail.line);
      }
    }

    // ============================================================
    // marker_size_from_radius (Python -> JS)
    // ============================================================
    function marker_size_from_radius(body) {
      if (!body.radius_km || body.radius_km <= 0) return 6.0;

      const rel = body.radius_km / R_EARTH_KM; // Erde -> 1
      let size = 4.0 * Math.pow(rel, 0.3);
      if (body.name === "Sonne") size *= 1.5;

      // clip 3..20
      size = Math.max(3.0, Math.min(20.0, size));
      return size;
    }

    // ============================================================
    // N-Body Beschleunigungen (Python -> JS)
    // ============================================================
    function compute_accelerations(bodies) {
      const n = bodies.length;
      for (const b of bodies) { b.ax = b.ay = b.az = 0.0; }

      for (let i=0;i<n;i++) {
        const bi = bodies[i];
        for (let j=0;j<n;j++) {
          if (i === j) continue;
          const bj = bodies[j];

          const dx = bj.x - bi.x;
          const dy = bj.y - bi.y;
          const dz = bj.z - bi.z;

          const r2 = dx*dx + dy*dy + dz*dz;
          const r = Math.sqrt(r2) + 1e-12;

          const factor = G * bj.mass / (r*r*r);
          bi.ax += factor * dx;
          bi.ay += factor * dy;
          bi.az += factor * dz;
        }
      }
    }

    // ============================================================
    // Velocity Verlet (Python -> JS)
    // ============================================================
    function velocity_verlet_step(bodies, dt) {
      const ax_old = bodies.map(b => b.ax);
      const ay_old = bodies.map(b => b.ay);
      const az_old = bodies.map(b => b.az);

      // Position update
      for (let i=0;i<bodies.length;i++) {
        const b = bodies[i];
        b.x += b.vx * dt + 0.5 * ax_old[i] * dt * dt;
        b.y += b.vy * dt + 0.5 * ay_old[i] * dt * dt;
        b.z += b.vz * dt + 0.5 * az_old[i] * dt * dt;
      }

      // neue Beschleunigungen
      compute_accelerations(bodies);

      // Geschwindigkeit update
      for (let i=0;i<bodies.length;i++) {
        const b = bodies[i];
        b.vx += 0.5 * (ax_old[i] + b.ax) * dt;
        b.vy += 0.5 * (ay_old[i] + b.ay) * dt;
        b.vz += 0.5 * (az_old[i] + b.az) * dt;
      }
    }

    // ============================================================
    // Trails
    // ============================================================
    function makeTrail(color) {
      const geom = new THREE.BufferGeometry();
      const positions = new Float32Array(TRAIL_MAX_POINTS * 3);
      geom.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      geom.setDrawRange(0, 0);

      const mat = new THREE.LineBasicMaterial({ color, transparent:true, opacity:0.65 });
      const line = new THREE.Line(geom, mat);
      line.frustumCulled = false;

      return { line, geom, positions, count: 0 };
    }

    function pushTrail(body) {
      if (!document.getElementById("trailsCheck").checked) return;

      const t = body.trail;

      // FIFO wie in der verbesserten Version
      if (t.count >= TRAIL_MAX_POINTS) {
        t.positions.copyWithin(0, 3);
        t.count = TRAIL_MAX_POINTS - 1;
      }

      const i = t.count;
      t.positions[i*3+0] = body.x;
      t.positions[i*3+1] = body.y;
      t.positions[i*3+2] = body.z;
      t.count++;

      t.geom.setDrawRange(0, t.count);
      t.geom.attributes.position.needsUpdate = true;
    }

    // ============================================================
    // Sterne (Hintergrund) wie im Python (sphärische Schale)
    // ============================================================
    function addStars(n_stars=600, rMin=60, rMax=120) {
      const geom = new THREE.BufferGeometry();
      const pos = new Float32Array(n_stars * 3);

      for (let i=0;i<n_stars;i++) {
        const phi = Math.random() * 2 * Math.PI;
        const costheta = (Math.random() * 2 - 1);
        const u = (Math.random() * (Math.pow(rMax,3) - Math.pow(rMin,3)) + Math.pow(rMin,3));
        const r = Math.pow(u, 1/3);

        const theta = Math.acos(costheta);

        pos[i*3+0] = r * Math.sin(theta) * Math.cos(phi);
        pos[i*3+1] = r * Math.sin(theta) * Math.sin(phi);
        pos[i*3+2] = r * Math.cos(theta);
      }

      geom.setAttribute("position", new THREE.BufferAttribute(pos, 3));
      const mat = new THREE.PointsMaterial({ color:0xffffff, size:0.12, transparent:true, opacity:0.5, sizeAttenuation:true });
      scene.add(new THREE.Points(geom, mat));
    }
    addStars();

    // ============================================================
    // Sonnensystem definieren (wie dein Python)
    // ============================================================
    const bodies = [];

    // Radien km
    const R_SUN     = 695700.0;
    const R_MERKUR  = 2439.7;
    const R_VENUS   = 6051.8;
    const R_ERDE    = 6371.0;
    const R_MARS    = 3389.5;
    const R_JUPITER = 69911.0;
    const R_SATURN  = 58232.0;
    const R_URANUS  = 25362.0;
    const R_NEPTUN  = 24622.0;
    const R_MOND    = 1737.4;

    // Sonne
    const sun = new Body({ name:"Sonne", mass:1.0, a:null, color:0xffff66, radius_km:R_SUN });
    bodies.push(sun);

    // Massen in Sonnenmassen
    const M_MERKUR  = 1.651e-7;
    const M_VENUS   = 2.447e-6;
    const M_ERDE    = 3.003e-6;
    const M_MARS    = 3.227e-7;
    const M_JUPITER = 9.545e-4;
    const M_SATURN  = 2.858e-4;
    const M_URANUS  = 4.366e-5;
    const M_NEPTUN  = 5.151e-5;
    const M_MOND    = M_ERDE * 0.0123;

    // Planeten (a,e,inc nur Info)
    bodies.push(new Body({ name:"Merkur",  mass:M_MERKUR,  a:0.387,  e:0.2056, inc_deg:7.0,  color:0x9aa0a6, radius_km:R_MERKUR }));
    bodies.push(new Body({ name:"Venus",   mass:M_VENUS,   a:0.723,  e:0.0068, inc_deg:3.4,  color:0xffa500, radius_km:R_VENUS }));
    bodies.push(new Body({ name:"Erde",    mass:M_ERDE,    a:1.000,  e:0.0167, inc_deg:0.0,  color:0x00bfff, radius_km:R_ERDE }));
    bodies.push(new Body({ name:"Mars",    mass:M_MARS,    a:1.524,  e:0.0934, inc_deg:1.85, color:0xff3333, radius_km:R_MARS }));
    bodies.push(new Body({ name:"Jupiter", mass:M_JUPITER, a:5.203,  e:0.0489, inc_deg:1.3,  color:0xf4a460, radius_km:R_JUPITER }));
    bodies.push(new Body({ name:"Saturn",  mass:M_SATURN,  a:9.537,  e:0.0542, inc_deg:2.49, color:0xffd700, radius_km:R_SATURN }));
    bodies.push(new Body({ name:"Uranus",  mass:M_URANUS,  a:19.191, e:0.0472, inc_deg:0.77, color:0x00ffff, radius_km:R_URANUS }));
    bodies.push(new Body({ name:"Neptun",  mass:M_NEPTUN,  a:30.07,  e:0.0086, inc_deg:1.77, color:0x8a2be2, radius_km:R_NEPTUN }));

    const earth = bodies.find(b => b.name === "Erde");

    // Mond hinzufügen (wie Python: um Erde, initial rechts von Erde + v_rel in y)
    const moon = new Body({ name:"Mond", mass:M_MOND, a:null, color:0xd3d3d3, radius_km:R_MOND });

    const r_moon = 0.00257; // AU
    moon.x = earth.x + r_moon;
    moon.y = earth.y;
    moon.z = 0.0;

    const GM_earth = G * earth.mass;
    const v_rel = Math.sqrt(GM_earth / r_moon);

    moon.vx = earth.vx;
    moon.vy = earth.vy + v_rel;
    moon.vz = earth.vz;

    moon.mesh.position.set(moon.x, moon.y, moon.z);
    bodies.push(moon);

    // Saturn-Ringe (optisch, optional)
    {
      const saturn = bodies.find(b => b.name === "Saturn");
      const ringGeo = new THREE.RingGeometry(0.22, 0.38, 80);
      const ringMat = new THREE.MeshStandardMaterial({
        color: 0xf2e8c9,
        roughness: 0.9,
        metalness: 0.0,
        transparent: true,
        opacity: 0.55,
        side: THREE.DoubleSide
      });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.rotation.x = Math.PI * 0.5;
      saturn.mesh.add(ring);
    }

    // Anfangsbeschleunigungen
    compute_accelerations(bodies);

    // ============================================================
    // Ideale Ellipsenbahnen (z=0), dashed (wie Python)
    // ============================================================
    const idealOrbitLines = [];
    function buildIdealOrbits() {
      // remove old
      for (const l of idealOrbitLines) scene.remove(l);
      idealOrbitLines.length = 0;

      const steps = 400;
      for (const b of bodies) {
        if (b.a === null) continue;

        const a = b.a, e = b.e;
        const points = [];
        for (let k=0;k<steps;k++) {
          const th = (k/(steps-1)) * 2*Math.PI;
          const x = a * Math.cos(th) - a * e;
          const y = a * Math.sin(th) * Math.sqrt(1 - e*e);
          const z = 0;
          points.push(new THREE.Vector3(x,y,z));
        }

        const geom = new THREE.BufferGeometry().setFromPoints(points);
        // "dashed": in three.js braucht man LineDashedMaterial + computeLineDistances
        const mat = new THREE.LineDashedMaterial({
          color: b.color,
          transparent:true,
          opacity:0.28,
          dashSize: 0.25,
          gapSize: 0.18
        });
        const line = new THREE.Line(geom, mat);
        line.computeLineDistances();
        idealOrbitLines.push(line);
        scene.add(line);
      }
    }
    buildIdealOrbits();

    // ============================================================
    // UI (Follow, Slider, Reset)
    // ============================================================
    const followSelect = document.getElementById("followSelect");
    const daysRange = document.getElementById("daysRange");
    const daysValue = document.getElementById("daysValue");
    const substepsRange = document.getElementById("substepsRange");
    const substepsValue = document.getElementById("substepsValue");
    const resetBtn = document.getElementById("resetBtn");
    const idealOrbitsCheck = document.getElementById("idealOrbitsCheck");

    // Follow-Optionen: "Keiner" + alle außer Sonne (wie Python Radiobuttons)
    function refillFollowOptions() {
      followSelect.innerHTML = "";
      const optNone = document.createElement("option");
      optNone.value = "__none__";
      optNone.textContent = "Keiner";
      followSelect.appendChild(optNone);

      for (const b of bodies) {
        if (b.name === "Sonne") continue;
        const opt = document.createElement("option");
        opt.value = b.name;
        opt.textContent = b.name;
        followSelect.appendChild(opt);
      }
      followSelect.value = "__none__";
    }
    refillFollowOptions();

    let followBody = null;

    followSelect.addEventListener("change", () => {
      followBody = (followSelect.value === "__none__")
        ? null
        : bodies.find(b => b.name === followSelect.value) || null;

      // OrbitControls Target sofort auf Körper setzen (ähnlich "zentrieren" in Python)
      if (followBody) controls.target.set(followBody.x, followBody.y, followBody.z);
    });

    function updateDaysLabel() {
      daysValue.textContent = Number(daysRange.value).toFixed(1);
    }
    updateDaysLabel();
    daysRange.addEventListener("input", updateDaysLabel);

    function updateSubstepsLabel() {
      substepsValue.textContent = String(parseInt(substepsRange.value, 10));
    }
    updateSubstepsLabel();
    substepsRange.addEventListener("input", updateSubstepsLabel);

    resetBtn.addEventListener("click", () => {
      camera.position.set(0, 6, 16);
      controls.target.set(0,0,0);
      controls.update();
    });

    idealOrbitsCheck.addEventListener("change", () => {
      const on = idealOrbitsCheck.checked;
      for (const l of idealOrbitLines) l.visible = on;
    });

    // ============================================================
    // Zoom wie dein Python on_scroll:
    // - zentriert auf followBody falls aktiv, sonst aktuelle Mitte (controls.target)
    // ============================================================
    renderer.domElement.addEventListener("wheel", (event) => {
      event.preventDefault();

      // emulate python scale: up -> 0.8 (zoom in), down -> 1.25 (zoom out)
      const scale = (event.deltaY < 0) ? 0.8 : 1.25;

      // Center: followBody oder controls.target
      const cx = followBody ? followBody.x : controls.target.x;
      const cy = followBody ? followBody.y : controls.target.y;
      const cz = followBody ? followBody.z : controls.target.z;

      // Kamera relativ zum Center skalieren
      const cam = camera.position;
      cam.set(
        cx + (cam.x - cx) * scale,
        cy + (cam.y - cy) * scale,
        cz + (cam.z - cz) * scale
      );

      // Target bleibt auf Center
      controls.target.set(cx, cy, cz);
      controls.update();
    }, { passive:false });

    // ============================================================
    // Animation (wie FuncAnimation):
    // animate(frame):
    //   dt = days_per_step*DAY_IN_YEARS
    //   velocity_verlet_step(...)
    //   sim_time += dt
    //   update meshes
    //   wenn follow -> "camera/axes nachführen"
    // ============================================================
    let sim_time = 0.0;
    const timeBox = document.getElementById("timeBox");

    function update_time_text() {
      const years = sim_time;
      const days_total = years * 365.25;
      timeBox.textContent = `t = ${years.toFixed(2)} Jahre (${Math.round(days_total)} Tage)`;
    }

    // Trails visibility toggle
    document.getElementById("trailsCheck").addEventListener("change", (e) => {
      const on = e.target.checked;
      for (const b of bodies) b.trail.line.visible = on;
    });

    function stepSimulation() {
      const days_per_step = parseFloat(daysRange.value);
      const dt = days_per_step * DAY_IN_YEARS;

      velocity_verlet_step(bodies, dt);
      sim_time += dt;

      for (const b of bodies) {
        b.mesh.position.set(b.x, b.y, b.z);
        pushTrail(b);
      }

      // "Kamera nachführen" wie Python: die Achsgrenzen werden verschoben.
      // In 3D Web: wir setzen target auf den Körper, Kamera bleibt relativ dazu.
      if (followBody) {
        // Behalte den Kameraversatz bei (ähnlich gleichbleibende "Zoom-Stufe")
        const cx = followBody.x, cy = followBody.y, cz = followBody.z;
        const offset = camera.position.clone().sub(controls.target);
        controls.target.set(cx, cy, cz);
        camera.position.copy(new THREE.Vector3(cx, cy, cz).add(offset));
      }

      update_time_text();
    }

    // Mehrere Integrationsschritte pro Frame (stabiler)
    function animate() {
      requestAnimationFrame(animate);

      const substeps = parseInt(substepsRange.value, 10);
      for (let i=0;i<substeps;i++) stepSimulation();

      controls.update();
      renderer.render(scene, camera);
    }
    update_time_text();
    requestAnimationFrame(animate);

    addEventListener("resize", () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
